brew install minikube // Kubernetes installation

this installation comes with docker and kubectl installed.
minikube start -vm hyperkite // start the orchestration with the hypervisor
kubectl create deployment nginx-depl --image=nginx // create the deployment(container) from nginx image.
kubectl exec -it nginx-depl bin/bash 
kubectl get  service // shows all the service available
Amazon EKS control tool - Amazon Elastic Kubernetes Service. 

docker build -t my-app:1.0 

//queryOptions
function groupOptions() {
    return defineOption({
        queryKey: ["group"],
        queryFn: async() => await fetch(url),
        staleTime: 6 * 60 * 1000,
        select: (data) => data.length,
    })
}

//useInfiniteQuery
useInfiniteQuery({
    queryKey: ["projects"],
    queryFn: async({queryKey, pageParam}) => await fetch(`/api/projects/?cursor=${pageParam}`).then(response => response.json()),
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor
})

//SSR using react query 

//setup _app.js 
import { ReactQueryProvider, QueryClient, HydrationBoundary } from "@tanstack/react-query";

export default function MyApp({Component, pageProps}) {
    const [qc] = React.useState(() => new QueryClient({
        defaultOptions: {
            queries: {
                staleTime: 5 * 1000
            }
        },
        queryOptions: {},
        mutationOptions: {}
    }))
    return (
        <ReactQueryProvider client={qc}>
            <HydrationBoundary client={dehydrate(qc)}>
                <Component {...pageProps} />
            </HydrationBoundary>
        </ReactQueryProvider>
    )
}

//project/tasks.page
const getProjectTasksPage = async ({ queryKey, signal }) => {
    const response = await fetch(url + queryKey, { signal })
    if(!response.ok) throw new Error(response.statusText)
    return response.json()
}
const qc = new QueryClient();
export async function getServerSideProps(context) {
    await qc.prefetchQuery({
        queryKey: ["project", "tasks"],
        queryFn: getProjectTasks
    })
    return {
        props: {
            dehydratedState: dehydrate(qc)
        }
    }
}

function Tasks() {
    const { data } = useQuery({ queryKey: ["project", "tasks"], queryFn: getProjectTasks})
    const { data: comments } = useQuery({ queryKey: ["project", "comments"], queryFn: getProjectTaskCommnet})

    return (
        <>
            {data.project.tasks.map((task) => (<>{task.title}</>))}
            {comments}
        </>
    )
}

export default function TaskRoute({ dehydratedState }) {

    return (
        <HydrationBoundary client={dehydratedState}>
            <Tasks />
        </HydrationBoundary>
    )
}