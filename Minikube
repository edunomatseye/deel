brew install minikube // Kubernetes installation

this installation comes with docker and kubectl installed.
minikube start -vm hyperkite // start the orchestration with the hypervisor
kubectl create deployment nginx-depl --image=nginx // create the deployment(container) from nginx image.
kubectl exec -it nginx-depl bin/bash 
kubectl get  service // shows all the service available
Amazon EKS control tool - Amazon Elastic Kubernetes Service. 

docker build -t my-app:1.0 

//queryOptions
function groupOptions() {
    return defineOption({
        queryKey: ["group"],
        queryFn: async() => await fetch(url),
        staleTime: 6 * 60 * 1000,
        select: (data) => data.length,
    })
}

//useInfiniteQuery
useInfiniteQuery({
    queryKey: ["projects"],
    queryFn: async({queryKey, pageParam}) => await fetch(`/api/projects/?cursor=${pageParam}`).then(response => response.json()),
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor
})

//SSR using react query 

//setup _app.js 
import { QueryClientProvider, QueryClient, HydrationBoundary } from "@tanstack/react-query";

export default function MyApp({Component, pageProps}) {
    const [qc] = React.useState(() => new QueryClient({
        defaultOptions: {
            queries: {
                staleTime: 5 * 1000
            }
        },
        queryOptions: {},
        mutationOptions: {}
    }))
    return (
        <QueryClientProvider client={qc}>
            <HydrationBoundary client={dehydrate(qc)}>
                <Component {...pageProps} />
            </HydrationBoundary>
        </QueryClientProvider>
    )
}

//project/tasks.page
const getProjectTasksPage = async ({ queryKey, signal }) => {
    const response = await fetch(url + queryKey, { signal })
    if(!response.ok) throw new Error(response.statusText)
    return response.json()
}
const qc = new QueryClient();
export async function getServerSideProps(context) {
    await qc.prefetchQuery({
        queryKey: ["project", "tasks"],
        queryFn: getProjectTasks
    })
    return {
        props: {
            dehydratedState: dehydrate(qc)
        }
    }
}

function Tasks() {
    const { data } = useQuery({ queryKey: ["project", "tasks"], queryFn: getProjectTasks})
    const { data: comments } = useQuery({ queryKey: ["project", "comments"], queryFn: getProjectTaskCommnet})

    return (
        <>
            {data.project.tasks.map((task) => (<>{task.title}</>))}
            {comments}
        </>
    )
}

export default function TaskRoute({ dehydratedState }) {

    return (
        <HydrationBoundary client={dehydratedState}>
            <Tasks />
        </HydrationBoundary>
    )
}

//customHook testing 
import { waitFor, renderHook } from '@testing-library/react'

const wrapper = ({ Component, pageProps, children }) => {
    <QueryClientProvider client={qc}>
        <Component {...pageProps} /> {children} <Outlet />
    </QueryClientProvider>
}
const { result } = renderHook(() => customHook(), { wrapper })
await waitFor(() => expect(result.current.isSuccess).tobe(true))
expect(result.current.data).toEqual('Hello')


//Route handlers
export async function GET(request: Request) {
    const data = await fetch('/api/settings', {
        signal: signal,
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json', 'API-KEY': 'hello' },
        next: {
            revalidate: 60,
            tags: ['settings']
        }
    }).then(response => response.json())
    return Response.json({ data })
}

//generic function inference.
import { z } from 'zod';

function awesomeFunction<TSchema extends Schema>(schema: z.Schema<TSchema>, handler: (input: TSchema) => void) {

    return (input: unknown) => handler(schema.parse(input))
}

const schema = z.object({
    id: z.number(),
    fullName: z.string(),
})
type Schema = z.infer<typeof schema>

awesomeFunction(schema, (input) => console.log(input.fullName))

//convert an array into a map/object.
const arr = [1,4,9,5,4,34,34]
const m = new Map();
m.forEach( x => {
    m.set(x, (m.get(x) || 0) + 1)
})

//write a sql query to extract year and month from timestamp 
SELECT EXTRACT (year FROM payment_ts) AS year,
    EXTRACT (month FROM payment_ts) AS mon,
    sum(amount) AS rev
FROM payment
GROUP BY year, mon
HAVING SUM(amount) > 20
ORDER BY rev ASC
LIMIT 10

learnt today the real difference btw a cloud engineer and a devOps, as cloud engineers are 
involued with infrastruture like aws, azure and gcp, networking, security while a devOps is 
involued with CI/CD tools and pipelines for ci and cd. 

react github interview profile

const userSchema = new mongoose.Schema({
    name: String,
  });
  
  // Define the Album schema
  const albumSchema = new mongoose.Schema({
    title: String,
    performer: String,
    cost: Number,
  });
  
  // Define the Purchase schema, referencing User and Album
  const purchaseSchema = new mongoose.Schema({
    user: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User',
    },
    album: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Album',
    },
  });

  const p1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'Yes ooo!'))
const p2 = new Promise((resolve, reject) => setTimeout(reject, 100, 'No ooo!'))
await Promise.race([p1, p2]).then(console.log).catch(e => console.error('Shayo '+e))
await Promise.any([p1, p2]).then(console.log).catch(e => console.warn('Shayo '+e))

function loader({ params, request }) {
    const noteId = params.noteid;
    const newNotes = notes.filter(note => note.id !== noteId)
    const selectedNote = notes.find(note => note.id === noteId )
}

curl --request POST \
--url 'http://localhost:3000/api/users' \
--header 'Content-Type: application/json' \
--data '{
    "gender": "Femal",
    "age": "34"
}'

fire and forget fetch calls
await fetch(url, {
    method: 'POST',
    headers: {
        "Authorization": 'bearer ' + token,
        "Content-Type": "application/json
    },
    body: JSON.stringify(newNotes)
})

import type { NextApiRequest, NextApiResponse } from 'next';
import Cors from 'cors';

const cors = Cors({
    methods: ['POST', 'GET', 'HEAD']
})

async function runMiddleware(req: NextApiRequest, res: NextApiResponse, fn: Function){
    return new Promise((resolve, reject) => {
        fn(req, res, (result: any) => {
            if(result instanceof Error){
                return reject(result)
            }
            return resolve(result)
        })
    })
}

export default async function handler(request: NextAPIRequest, response: NextAPIResponse) {
    await runMiddleware(request, response, cors)
    response.json({})
}

//Typescript builder pattern

interface FooBuilder<T = never> {
    add: <newType>() => FooBuilder<newType | T>;
    value: T
}

declare const u: FooBuilder;

const r = u.add<string>()
 .add<number>()
 .add<boolean>().value;

console.log(r);


import { relations } from 'drizzle-orm';

export const user = pgTable('user', {
    id: serial('id').primaryKey(),
    name: text('name')
})

export const userRelations = relations(user, ({ many }) => ({
    posts: many(post)
}))

export const post = pgTable('post', {
    id: serial('id').primaryKey(),
    title: text('title').notNull(),
    content: text('content'),
    authorId: integer('author_id'),
})

export const postRelations = relations(post, ({ one }) => ({
    author: one(user, {
        fields: [post.authorId],
        references: [user.id]
    })
}))

type Fruits = '@M' | '@G' | '@A';
type Switch<T extends Fruits> = {
    '@M': 'Mango',
    '@G': 'Grape',
    '@A': 'Apple',
}[T];
type Mango = Switch<'@M'>
const mango: mango = 'Mango'

Even though native ESM is now widely supported, shipping unbundled ESM in production is still inefficient (even with HTTP/2) due to the additional network round trips caused by nested imports. To get the optimal loading performance in production, it is still better to bundle your code with tree-shaking, lazy-loading and common chunk splitting (for better caching).


Happy 31th last day of 2023.

We're thrilled to welcome you to the exciting year of 2024!

May the year be filled with achievements, growth, and moments of joy that leave a lasting impact.

database index is a data structure that referecnce the location of records in a table based off one or multiple attribute of same table.

createConfig(), createEnv({
    clientPrefix: 'PUBLIC_',
    server: {
        'DATABASE_URL': z.string().url(),
        'API_TOKEN': z.string().min(1)
    },
    client: {
        'PUBLIC_PUBLISH_KEY': z.string().min(1)
    },
    runtimeEnv: process.env,
})

in as much as we write test to boost confidence in the way users use our application, we should 
also test in a way that users uses our application and not the implementation details.


import express, { Request, Response, NextFunction, Express } from 'express';
const app: Express = express();

app.use(express.json());

const port = process.env.PORT || 8080;

app.get(
  '/',
  async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      res.status(200).json({
        message: 'Hurray!! we create our first server on bun js',
        success: true,
      });
    } catch (error: unknown) {
      next(new Error((error as Error).message));
    }
  },
);

app.listen(port, () => {
  console.log(`Server is up and running on port ${port}`);
});

bun run server.ts

how to clone a remote github branch 
git clone -b eo/sc-2345/getting-back-into-2024 <remote-repo-url>
git clone -b eo/sc-2345/getting-back-into-2024 --single-branch <remote-repo-url>

babel is synonym to polyfill and transpilation, as es5 is to class and arrow function in js.

bable.config.js 
export default defineConfig({
    presets: [
        "@babel/preset-env"
    ]
})


import { createClient } from '@supabase/supabase-js'

// Create a single supabase client for interacting with your database
const supabase = createClient('https://xyzcompany.supabase.co', 'public-anon-key')

type APIRoute<T> = (init: {params: T, request: Request}) => Promise<Response>
type Params = {gender: string, age: number}
async function GET (ctx: { params: Params, request: Request}) {
    const token = ctx.request.headers.get('Authorization')
    return new Response(JSON.stringify({
        gender: ctx.params.gender,
        age: ctx.params.age,
        token
    }))
}

import * as schema from './src/schema'
import mysql from 'mysql2/promise'
import { drizzle } from '@drizzle-orm/mysql2'

export const connection = await mysql.createConnection({
    localhost,
    port,
    database,
    username,
    password
})
export const db = drizzle(connection, { schema })



import { migrate } from '@drizzle-orm/mysql2/migrator'
await migrate(db, { migrationsFolder: './drizzle' })
connection.end()

export const CounterContext = createContext([{ count: 0 }, {}]);

export function CounterProvider(props) {
  const [state, setState] = createStore({ count: props.count || 0 });
  const counter = [
    state,
    {
      increment() {
        setState("count", (c) => c + 1);
      },
      decrement() {
        setState("count", (c) => c - 1);
      },
    },
  ];

  return (
    <CounterContext.Provider value={counter}>
      {props.children}
    </CounterContext.Provider>
  );
}

vinxi
Compose full stack applications (and frameworks) using Vite, the versatile bundler and dev server, and Nitro, the universal production server. The core primitive in vinxi is a router.


import { queryClient } from "./query-client";

export const loader = ({ params }) => {
  return queryClient.fetchQuery(queryKey, queryFn, {
    staleTime: 10000,
  });
};

import { queryClient } from "./query-client";

export const action = async ({ request, params }) => {
  const formData = await request.formData();
  const updates = Object.fromEntries(formData);
  await updateContact(params.contactId, updates);
  await queryClient.invalidateQueries(["contacts"]);
  return redirect(`/contacts/${params.contactId}`);
};

import Database from 'better-sqlite3'

const db = new Database('sql.db')
const data = db.exec(query)
const insertData = db.prepare("INSERT INTO user(id, name, email) values(?, ?, ?)")

data = [{},{},{}]
data.forEach(user => {
    insertData.run(user.id, user.name, user.email)
})
db.close()

import { Client } from 'pg'

const client = new Client({
    connectionString: 'postgres://localhost:3456/db',
    host,
    port,
    username,
    password,
    database
})

migrate(drizzle(client)));
drizzle(client).select().from('table')

export default {
    async fetch(
        req: Request,
        env: Env,
        ctx: ExecutionContext
    ): Promise<Response> {
        
        return Response.json()
    }
}

const db = drizzle(async (sql, params, method) => {
    try {
        const response = axios.post('http://localhost:3232/query', {sql, params, metho})
        return {
            data: response.data
        }
    } catch(e) {
        console.error(e)
        return { data: [] }
    }
})

on:
    push:
        branches: [ master ]
    pull_request:
        branches: [ master ]

jobs: 
    build:

        runs-on: ${{matrix.os}}
        strategy:
            matrix:
                os: [ubuntu-latest, macOS-latest, windows-latest]

        steps:
        - uses: actions/checkout@v2
        - name: Set up JDK 1.8
          run: .gradle ...
        - name: Build and push Docker Image
          uses: mr-smithers-excellent/docker-build-push@v4
          with:
            image: teotechng/demo-app
            registry: docker.io
            username: ${{secrets.DOCKER_USERNAME}}
            password: ${{secrets.DOCKER_PASSWORD}}


            type TOptions = {
                method: 'GET' | 'POST',
                url: string,
            }
            type TGInput = {
                [index: number]: string,
                params: Record<string, string>,
                url: string
            }
            type DefineFetcher = <TInput extends {}, TOutput>(options: TOptions) => (input: TInput) => Promise<TOutput>
            
            const get = ({params, url}: TGInput) => {
                return fetch(url+new URLSearchParams(params).toString(), {method: 'GET'}).then(response => response.json()).catch(console.error)
            }
            const post = ({params, url}: TGInput) => {
                return fetch(url, {method: 'POST', body: JSON.stringify(params)}).then(response => response.json()).catch(console.error)
            }
            
            const url = 'https://jsonplaceholder.typicode.com/comments?'
            
            const defineFetcher: DefineFetcher = ({method, url}) => (params) => {
                const fetcher = method === 'GET'? get: post;
                return fetcher({params, url})
            }
            
            const getUser = defineFetcher<{postId: string}, {name: string, gender: "Male"|"Female"}>({method: 'GET', url})
            getUser({postId: '1'}).then(console.log)

            export default async function Page(request: NextRequest) {
                async function createProduct(formData: FormData) {
                    'use server'
                    const product = Object.fromEntriest(formData.entries());
                    const name = formData.get('productName')
                    const products = db.select().from(product).getAll()
                    await db.insert(products).values(product)
                    revalidateTag('products')
                }
            
                return (
                    <>
                        <form action={createProduct}>
                            <inpupt name="productName" />
                            <input type="submit" value="Submit" />
                        </form>
                    </>
                )
            }

import { type NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers'

export default async function middleware(request: NextRequest) {
    const token = request.headers.get('Authorization')
    if(request.nextUrl.pathname === '/profile')
        NextResponse.redirect(new URL('/', new Request('/').url))

    const theme = cookies.get('theme')
    if(!theme){
        cookies.set('theme', 'dark')
    }

    return NextResponse.next()
}

export const config = {
    matcher: '/prodile'
}

@Component({
    standalone: true,
    selector: 'app-post',
    template: `
        @if(post()){
            <h2>Post</h2>
            <div>{{ post().title }}</div>
            <div>{{ post().description }}</div>
        }
    `,
})
export class PostComponent {
    private readonly http = inject(HttpClient)
    postId = input.required<string>();
    post = toSignal(toObservable(this.postId).pipe(
        filter(id => !!id),
        switchMap(id => this.http.get<Post>(`https://jsonplaceholder.typicode.com/post/{id}`))
    ), {initialValue: null})
}

<form action={formAction} onSubmit={onSubmit}>
    </form>

const onSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const formData = new FormData(e.currentTarget.value)
}

function formAction(formData: FormData) {
    const title = formData.get('title')
    const formD = Object.fromEntries(formData)
    
}

export function SubmitForm() {
    const formStatus = useFormStatus()
    const isLoading = formStatus.isLoading
    return <button type='submit'>
        {isLoading ? 'Loading': 'Submit'}
        </button>
}

body {
    color: var(--text);
    background-color: var(--secondary);
    font-family: var(--body-font); /* Token for font */
  }
  
  .button {
    background-color: var(--primary);
    padding: var(--spacing-small);
    border-radius: var(--border-radius-default); /* Token for border radius */
  }

SELECT *
FROM user u
JOIN profile p
ON user.pid === profile.id
WHERE constraints
GROUP BY 
HAVING constriaints
ORDER BY ASC
LIMIT 5

async function retry<T>(fn: () => Promise<T>, retries: number = 5) {
    let result;
    try {
        result = await fn()
    } catch(e) {
        if(retries > 0){
            console.info('Retrying the promise function')
            await retry(fn, --retries)
        }
        //throw(e)

        do {
            console.log('hello',e)
            --retries;
        } while(retries > 0)

        while(retries > 0) {
            console.log('whiling...',e)
            --retries;
        }
    }
    return result
}

const r = retry(() => Promise.reject(5), 3)

import * as z from 'zod';
import { zodResolver } from '@hookform/resolvers/zod'
import { useForm } from 'react-hook-form'

const schema = z.object({
    name: z.string(),
    age: z.number()
})
type Schema = z.infer<typeof schema>

const App = () => {
    const { register, handleSubmit } = useForm<Schema>({
        resolver: zodResolver(schema)
    })
    const onSubmit = (data: Schema) => {
        console.log(data)
    }
    
    return (
        <form onsubmit={handleSubmit(onSubmit)}>
            <input {...register('name')} />
            <input {...register('age', {valueAsNumber:true})} type="number" />
            <input type='submit' />
        </form>
    )
}

const useToggle = (initialValue: boolean) => {
    const [value, setValue] = React.useState<boolean>(initialValue)
    const toggleValue = () =>setValue(value => !value)
    return [value, toggleValue] as const
}

type Prettify<T> = T extends object ? {[K in keyof T]: T[K]} & {} : T

const [isPending, startTransition] = useTransition();
const [inputV, setInputV] = useState()
const [query, setQuery] = useState()

const handleChange = (e) => {
    setInputV(e.target.value)
    startTransition(() => setQuery(e.target.value))
}


<input value={inputV} onchange={handleChange} />
{isPending && <div> Filtered list is loading</div>}
{filterStuff.map()}

//Immediate invoked function expression in modules
(function(exports, require, module, __filename, __dirname) {
    return 
})()

const EventEmitter = require("node:events");

const eventEmitter = new EventEmitter();

emitterEmitter.on('Order-Pizza', () => {
    console.log("Ordered Pizza is just a minute away")
})
eventEmitter.emit('Order-Pizza');

const fs = require('node:fs')
const c = fs.readFileSync(path.join(__dirname, schema.json), 'utf-8')
console.log(c);

fs.readFile('./schema.json', 'utf-8', (error, data) => {
    if(error) throw new Error('Error reading file');
    console.log(data)
})

const readableStream = fs.createReadStream('./text1.txt', {encoding: 'utf-8'})
const writeableStream = fs.createWriteStream('./text2.txt')
readableStream.on('data', (chunk) => {
    console.log(data)
    writeableStream.write(chunk);
})

type EventConfig<Events extends { kind: string }> = {
    [E in Events as E["kind"]]: (event: E) => void;
}
 
type SquareEvent = { kind: "square", x: number, y: number };
type CircleEvent = { kind: "circle", radius: number };
 
type Config = EventConfig<SquareEvent | CircleEvent>

import { sql } from "drizzle-orm";
import { timestamp, pgTable } from "drizzle-orm/pg-core";
const table = pgTable('table', {
  timestamp1: timestamp('timestamp1'),
  timestamp2: timestamp('timestamp2', { precision: 6, withTimezone: true }),
  timestamp3: timestamp('timestamp3').defaultNow(),
  timestamp4: timestamp('timestamp4').default(sql`now()`),
});

import { serial, text, integer, pgTable } from "drizzle-orm/pg-core";
export const user = pgTable("user", {
  id: serial("id"),
  name: text("name"),
});
export const book = pgTable("book", {
  id: serial("id"),
  name: text("name"),
  authorId: integer("author_id").references(() => user.id)
});

function fixedForwardRef<T, P = {}>(render: (props: P, ref: React.Ref<T>) => React.ReactNode)
    : (props: P & React.RefAttributes<T>) => React.ReactNode
{
    return React.forwardRef(render) as any;
}

const ForwardedRef = fixedForwardRef(Table)
<ForwardedRef data={} renderRow={() => { return <tr />}} />

import 'dotenv/config';
import { migrate } from 'drizzle-orm/mysql2/migrator';
import { db, connection } from './db';
// This will run migrations on the database, skipping the ones already applied
await migrate(db, { migrationsFolder: './drizzle' });
// Don't forget to close the connection, otherwise the script will hang
await connection.end();

import * as schema from './schema';
import { drizzle } from 'drizzle-orm/...';
const db = drizzle(client, { schema });
const result = await db.query.users.findMany({
  with: {
    posts: true      
  },
});

const Element = React.createElement('div', {id: 'client'}, 'Login')
gives you an object: 
{
    "type": "div",
    "props": {
        id: "client",
        children: 'Login'
    }
}

ReactDOM.render(Element, node)

export default function Page() {
    async function createInvoice(formData: FormData) {
      'use server'
   
      const rawFormData = {
        customerId: formData.get('customerId'),
        amount: formData.get('amount'),
        status: formData.get('status'),
      }
    }
   
    return <form action={createInvoice}>...</form>
}

class User extends Component {
    constructor(props) {
      super(props);
      this.handleClick = this.handleClick.bind(this);
    }
    handleClick() {
      console.log("SingOut triggered");
    }
    render() {
      return <button onClick={this.handleClick}>SingOut</button>;
    }
  }

  import { test, expect } from '@playwright/test';

test('has title', async ({ page }) => {
  await page.goto('https://playwright.dev/');

  // Expect a title "to contain" a substring.
  await expect(page).toHaveTitle(/Playwright/);
});

test('get started link', async ({ page }) => {
  await page.goto('https://playwright.dev/');

  // Click the get started link.
  await page.getByRole('link', { name: 'Get started' }).click();

  // Expects page to have a heading with the name of Installation.
  await expect(page.getByRole('heading', { name: 'Installation' })).toBeVisible();
});

import { Card } from '@/app/ui/dashboard/cards';
import RevenueChart from '@/app/ui/dashboard/revenue-chart';
import LatestInvoices from '@/app/ui/dashboard/latest-invoices';
import { lusitana } from '@/app/ui/fonts';
import { fetchLatestInvoices, fetchCardData } from '@/app/lib/data';
import { Suspense } from 'react';
import { RevenueChartSkeleton } from '@/app/ui/skeletons';
 
export default async function Page() {
  const latestInvoices = await fetchLatestInvoices();
  const {
    numberOfInvoices,
    numberOfCustomers,
    totalPaidInvoices,
    totalPendingInvoices,
  } = await fetchCardData();
 
  return (
    <main>
      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>
        Dashboard
      </h1>
      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
        <Card title="Collected" value={totalPaidInvoices} type="collected" />
        <Card title="Pending" value={totalPendingInvoices} type="pending" />
        <Card title="Total Invoices" value={numberOfInvoices} type="invoices" />
        <Card
          title="Total Customers"
          value={numberOfCustomers}
          type="customers"
        />
      </div>
      <div className="mt-6 grid grid-cols-1 gap-6 md:grid-cols-4 lg:grid-cols-8">
        <Suspense fallback={<RevenueChartSkeleton />}>
          <RevenueChart />
        </Suspense>
        <LatestInvoices latestInvoices={latestInvoices} />
      </div>
    </main>
  );
}

nx release --dry-run --first-release

test.describe("navigation", () => {
    test.beforeEach(async ({ page }) => {
        await page.goto('http://localhost:3000')
    })

    test('main navigation', ({ page }) => {
        await expect(page).toHaveURL('http://localhost:3000')
    })
})

name: Playwright Tests
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
jobs:
  test:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: 18
    - name: Install dependencies
      run: npm ci
    - name: Install Playwright Browsers
      run: npx playwright install --with-deps
    - name: Run Playwright tests
      run: npx playwright test
    - uses: actions/upload-artifact@v3
      if: always()
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 30

Generate the migration
pnpm drizzle-kit generate:mysql


import { defineConfig } from '@playwright/test';

export default defineConfig({
  webServer: [
    {
      command: 'npm run start',
      url: 'http://127.0.0.1:3000',
      timeout: 120 * 1000,
      reuseExistingServer: !process.env.CI,
    },
    {
      command: 'npm run backend',
      url: 'http://127.0.0.1:3333',
      timeout: 120 * 1000,
      reuseExistingServer: !process.env.CI,
    }
  ],
  use: {
    baseURL: 'http://127.0.0.1:3000',
  },
});


import { SQLWrapper, and, eq, gte, ilike } from 'drizzle-orm';
const filters: SQLWrapper[] = [];
const searchFilter = true;
const priceFilter = true;
const statusFilter = true;
if (searchFilter) filters.push(ilike(orders.title, 'my-order'));
if (priceFilter) filters.push(gte(orders.price, 1000));
if (statusFilter) filters.push(eq(orders.status, 'pending'));
const result = await db
  .select()
  .from(orders)
  .where(and(...filters));

  import React, { useState, useEffect } from 'react';
import { useFormState, useFormStatus } from 'react-dom';

// Replace with your actual server action function
const submitForm = async (data) => {
  // Simulate server-side processing
  const response = await new Promise((resolve) => {
    setTimeout(() => {
      resolve({ success: Math.random() > 0.5 });
    }, 1000);
  });
  return response;
};

const MyForm = () => {
  const [formData, formAction] = useFormState(submitForm);
  const { pending } = useFormStatus();

  const [name, setName] = useState('');
  const [email, setEmail] = useState('');

  const handleSubmit = (event) => {
    event.preventDefault();
    formAction({ name, email });
  };

  useEffect(() => {
    if (formData.success) {
      // Handle successful submission
      setName('');
      setEmail('');
      alert('Form submitted successfully!');
    } else if (formData.error) {
      // Handle submission error
      alert('There was an error submitting the form. Please try again.');
    }
  }, [formData]);

  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="name">Name:</label>
      <input
        type="text"
        id="name"
        value={name}
        onChange={(e) => setName(e.target.value)}
      />
      <label htmlFor="email">Email:</label>
      <input
        type="email"
        id="email"
        value={email}
        onChange={(e) => setEmail(e.target.value)}
      />
      <button type="submit" disabled={pending}>
        Submit {pending ? '...' : ''}
      </button>
    </form>
  );
};

export default MyForm;


const items = Array.from({length: 100}).map((_, i) => ({id: i, name: `Item ${i}`}))
type Item = typeof items[number]
const LIMIT = 10;
export function fetchItems({pageParam}: {pageParam: number}):Promise<{
    data: Item[];
    currentPage: number;
    nextPage: number|null
}> {

    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const nextCursor = pageParam + LIMIT
            resolve({
                data: items.slice(pageParam, nextCursor),
                currentPage: pageParam,
                nextPage: nextCursor < items.length? nextCursor: null,
            })
        }, 2000)
    })

}

import CardWrapper from '@/app/ui/dashboard/cards';
// ...
import {
  RevenueChartSkeleton,
  LatestInvoicesSkeleton,
  CardsSkeleton,
} from '@/app/ui/skeletons';
 
export default async function Page() {
  return (
    <main>
      <h1 className={`${lusitana.className} mb-4 text-xl md:text-2xl`}>
        Dashboard
      </h1>
      <div className="grid gap-6 sm:grid-cols-2 lg:grid-cols-4">
        <Suspense fallback={<CardsSkeleton />}>
          <CardWrapper />
        </Suspense>
      </div>
      // ...
    </main>
  );
}

class MyWeakMap {
  #marker = Symbol("MyWeakMapData");
  get(key) {
    return key[this.#marker];
  }
  set(key, value) {
    key[this.#marker] = value;
  }
  has(key) {
    return this.#marker in key;
  }
  delete(key) {
    delete key[this.#marker];
  }
}

function cached(getter) {
  // A Map from string URLs to WeakRefs of results
  const cache = new Map();
  return async (key) => {
    if (cache.has(key)) {
      return cache.get(key).deref();
    }
    const value = await getter(key);
    cache.set(key, new WeakRef(value));
    return value;
  };
}

function monthlyCharge(month, subscription, users) {
  // Check for invalid inputs
  if (!month || !users) {
    return 0;
  }

  // Check if subscription is present and active for the given month
  if (!subscription || !subscription.monthlyPriceInCents) {
    return 0;
  }

  const monthDate = new Date(month); // Convert month string to Date object

  // Calculate the start and end dates of the month for billing
  const startDate = firstDayOfMonth(monthDate);
  const endDate = lastDayOfMonth(monthDate);

  // Filter active users based on their activation and deactivation dates
  const activeUsers = users.filter(user => {
    const userStartDate = user.activatedOn || startDate; // Handle missing activatedOn
    const userEndDate = user.deactivatedOn ? nextDay(user.deactivatedOn) : endDate; // Handle missing/null deactivationOn

    // Check if user was active within the billing period (inclusive)
    return userStartDate <= endDate && userEndDate > startDate;
  });

  // Calculate the total monthly charge in cents
  const totalCharge = activeUsers.length * subscription.monthlyPriceInCents;

  // Round to the nearest cent
  return Math.round(totalCharge);
}

import { createElement } from 'react';

export default function App() {
  return createElement(
    'h1',
    { className: 'greeting' },
    'Hello, this is a JSX Code!'
  );
}

dynamic module loading,
import('./dynamic/module/loading.js').then((module) => {
  // do something with the module
})

await page.getByLabel('Upload file').setInputFiles(path.join(__dirname, 'myfile.pdf'));

// Select multiple files
await page.getByLabel('Upload files').setInputFiles([
  path.join(__dirname, 'file1.txt'),
  path.join(__dirname, 'file2.txt'),
]);

// Remove all the selected files
await page.getByLabel('Upload file').setInputFiles([]);

// Upload buffer from memory
await page.getByLabel('Upload file').setInputFiles({
  name: 'file.txt',
  mimeType: 'text/plain',
  buffer: Buffer.from('this is test')
});

import { Router, Route, Set } from '@redwoodjs/router'
import ScaffoldLayout from 'src/layouts/ScaffoldLayout'
import BlogLayout from 'src/layouts/BlogLayout'

const Routes = () => {
  return (
    <Router>
      <Set wrap={ScaffoldLayout} title="Posts" titleTo="posts" buttonLabel="New Post" buttonTo="newPost">
        <Route path="/admin/posts/new" page={PostNewPostPage} name="newPost" />
        <Route path="/admin/posts/{id:Int}/edit" page={PostEditPostPage} name="editPost" />
        <Route path="/admin/posts/{id:Int}" page={PostPostPage} name="post" />
        <Route path="/admin/posts" page={PostPostsPage} name="posts" />
      </Set>
      <Set wrap={BlogLayout}>
        <Route path="/article/{id:Int}" page={ArticlePage} name="article" />
        <Route path="/contact" page={ContactPage} name="contact" />
        <Route path="/about" page={AboutPage} name="about" />
        <Route path="/" page={HomePage} name="home" />
      </Set>
      <Route notfound page={NotFoundPage} />
    </Router>
  )
}

export default Routes


import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      ignoredRouteFiles: ["**/*.css"],
    }),
  ],
});

Why should we not update the state directly?
If you try to update the state directly then it won't re-render the component.

//Wrong
this.state.message = "Hello world";
Instead use setState() method. It schedules an update to a component's state object. When state changes, the component responds by re-rendering.

//Correct
this.setState({ message: "Hello World" });
Note: You can directly assign to the state object either in constructor or using latest javascript's class field declaration syntax.

type SayHelloFn = (name: string) => string;

(function (name: string): string {
    return `hello ${name}`
}) satisfies SayHelloFn;

const hi = sayHello()

const sayHellos: SayHelloFn = (name: string) => {
    return ``
} satisfies SayHelloFn

npx nx-cloud start-ci-run --distribute-on="5 linux-medium-js" --stop-agents=""

await expect(page.getByTestId('status')).toHaveText('Submitted');

{
  "name": "myreactapp",
  "scripts": {
    "start": "nx serve",
    "build": "nx build",
    "test": "nx test"
  }
  ...
}

import React, { forwardRef, useRef } from 'react';

const Table = <T,>(props: {data: T[], renderRow: (row: T) => React.ReactNode}): React.ReactNode => {
    return (
        <table>
        {props.data.map((row, index) => <props.renderRow key={index} {...row} />)}
        </table>
    )
}

<Table data={["a", "b"]} renderRow={(row) => {
    return (row)
}} />


const Tables = React.forwardRef(<T,>(props: {data: T[], renderRow: (row: T) => React.ReactNode }, ref: React.ForwardedRef<HTMLTableElement>): React.ReactNode => {
    return (
        <table ref={ref}>Hello {
            props.data.map((row, index) => <props.renderRow key={index} {...row} />)
        }</table>
    )
})

function fixedForwardRef2 <T, P = {}>(
    render: (props: P, ref: React.Ref<T>) => React.ReactNode
    ): (props: P & React.RefAttributes<T>) => React.ReactNode {
    return React.forwardRef(render) as any;
}

function fixedForwardRef<T, P = {}>(
  render: (props: P, ref: React.Ref<T>) => React.ReactNode
): (props: P & React.RefAttributes<T>) => React.ReactNode {
  return React.forwardRef(render) as any;
}

declare function <T extends z.ZodType>createHandler(
  schema: T, 
  handler: (
      req: Omit<NextApiRequest, keyof z.output<T>> & z.output<T>, 
      res: NextApiResponse
  ) => void | Promise<void>
): NextApiHandler;

const schema = z.object({
  body: z.object({
      id: z.string(),
  })
})
const handler = createHandler(schema, (req) => {
  req.body.id;
})

function cached(fetcher) {
  const cache = new Map();

  return async (key) => {
    if(cache.has(key)) {
      return cache.get(key);
    }

    const value = await fetch(key);
    cache.set(key, new WeakMap(value));
    return value;
  }
}

import { pgTable, serial, text, integer, jsonb } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const usersRelations = relations(users, ({ one }) => ({
  profileInfo: one(profileInfo),
}));
export const profileInfo = pgTable('profile_info', {
  id: serial('id').primaryKey(),
  userId: integer('user_id').references(() => users.id),
  metadata: jsonb('metadata'),
});

import { pgTable, serial, text, integer } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name'),
});
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content'),
  authorId: integer('author_id'),
});
export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id],
  }),
}));

declare const fetchWithSchema: <T extends z.ZodSchema>(
  url: string,
  schema: T
) => Promise<z.output<T>> | z.output<T>

declare const fetchAsSchema: <T>(
  url: string,
  schema: {
      parse: (input: unknown) => T
  }
) => Promise<T>

const response = fetchWithSchema('http://', z.object({
  id: z.number(),
  fullName: z.string()
}))

class ClearableWeakMap {
  #wm;
  constructor(init) {
    this.#wm = new WeakMap(init);
  }
  clear() {
    this.#wm = new WeakMap();
  }
  delete(k) {
    return this.#wm.delete(k);
  }
  get(k) {
    return this.#wm.get(k);
  }
  has(k) {
    return this.#wm.has(k);
  }
  set(k, v) {
    this.#wm.set(k, v);
    return this;
  }
}

class User extends Component {
  constructor(props) {
    super(props);
    this.handleClick = this.handleClick.bind(this);
  }
  handleClick() {
    console.log("SingOut triggered");
  }
  render() {
    return <button onClick={this.handleClick}>SingOut</button>;
  }
}

const cache = new WeakMap();
function handleObjectValues(obj) {
  if (cache.has(obj)) {
    return cache.get(obj);
  }
  const result = Object.values(obj).map(heavyComputation);
  cache.set(obj, result);
  return result;
}

yargs, process.argv, process.argk,

have your node script with the prefix #/usr/bin/node node 
console.log('we are workinig')

inside package.json

bin: {
    "showworking": "./index.js"
}
sude npm install -showworking --name=edun
import { yargs } from 'yargs'
const { argv } = yargs(process.argv);

const pokemon = argv.pokemon;

npm install inquirer

const inquirer = require('inquirer')
const prompt = inquirer.createPromptModule();

prompt([
    {
        'type': 'input',
        'name': 'pokemon',
        'message': 'Enter a pokemon name to view its first 5 moves'
    }
]).then((answers) => {
    const pokemon = answers.pokemon
    createPokemonMoves(pokemon)
})


const AsyncIteratorPrototype = Object.getPrototypeOf(
  Object.getPrototypeOf(Object.getPrototypeOf((async function* () {})())),
);

const ObjectWithId = z.object({
  id: z.string().uuid(),
});

const User = ObjectWithId.extend({
  name: z.string(),
});

const Post = ObjectWithId.extend({
  title: z.string(),
  body: z.string(),
});

const Comment = ObjectWithId.extend({
  text: z.string(),
});

async function retry<T>(
  fn: (arg: number) => Promise<T>, 
  retries: number = 5
): Promise<T> {
  try {
      return await fn(232);
  } catch(e) {
      if(retries > 0) {
          console.error(e);
          return await retry(fn, retries - 1)
      }
      throw e
  }
}

retry(() => Promise.resolve('Iyanu')).then(str => {
  console.log(str)
})

createBrowserRouter([
  {
    path: '/',
    element: <Root />
  },
  {
    path: '/contacts',
    element: <Contact loader={} action={} />
  },
  {
    element: <AuthorizedLayout loader={} action={} />,
    children: [
      {
        path: '/login',
        element: <Login />,
        loader: redirectIfUser,
      },
      {
        path: '/logout',
        action: logout
      }
    ]
  }
])

// Configure nested routes with JSX
createBrowserRouter(
  createRoutesFromElements(
    <Route path="/" element={<Root />}>
      <Route path="contact" element={<Contact />} />
      <Route
        path="dashboard"
        element={<Dashboard />}
        loader={({ request }) =>
          fetch("/api/dashboard.json", {
            signal: request.signal,
          })
        }
      />
      <Route element={<AuthLayout />}>
        <Route
          path="login"
          element={<Login />}
          loader={redirectIfUser}
        />
        <Route path="logout" action={logoutUser} />
      </Route>
    </Route>
  )
);

// Or use plain objects
createBrowserRouter([
  {
    path: "/",
    element: <Root />,
    children: [
      {
        path: "contact",
        element: <Contact />,
      },
      {
        path: "dashboard",
        element: <Dashboard />,
        loader: ({ request }) =>
          fetch("/api/dashboard.json", {
            signal: request.signal,
          }),
      },
      {
        element: <AuthLayout />,
        children: [
          {
            path: "login",
            element: <Login />,
            loader: redirectIfUser,
          },
          {
            path: "logout",
            action: logoutUser,
          },
        ],
      },
    ],
  },
]);

const buffer = new ArrayBuffer(8, { maxByteLength: 16 });
const float32 = new Float32Array(buffer);

console.log(float32.byteLength); // 8
console.log(float32.length); // 2

buffer.resize(12);

console.log(float32.byteLength); // 12
console.log(float32.length); // 3

async function loadCam() {
  const {promise, resolve, reject} = Promise.withResolvers();
  const stream = await navigator.mediaDevices.getUserMediaStream({video: true});
  const recorder = new MediaRecorder(stream);

  const chunks: Blob[] = [];
  recorder.ondataavailable = (event) => chunks.push(event.data)
  recorder.stop = (event) => resolve(window.URL.createObjectURL(new Blob(chunks)))
  recorder.error = reject
  recorder.start(1000)

  return promise
}
loadCam.then(str => divEl.src = str);

import cluster from 'node:cluster';
import http from 'node:http';
import { availableParallelism } from 'node:os';
import process from 'node:process';

const numCPUs = availableParallelism();

if (cluster.isPrimary) {
  console.log(`Primary ${process.pid} is running`);

  // Fork workers.
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork();
  }

  cluster.on('exit', (worker, code, signal) => {
    console.log(`worker ${worker.process.pid} died`);
  });
} else {
  // Workers can share any TCP connection
  // In this case it is an HTTP server
  http.createServer((req, res) => {
    res.writeHead(200);
    res.end('hello world\n');
  }).listen(8000);

  console.log(`Worker ${process.pid} started`);
}

type PersonAttr = {
  height?: 'small' | 'medium' | 'tall',
  age?: number
}

const seyi = {
  height: 'small',
  get age() {
      return Math.random() > 0.5 ? 2024 : undefined
  }
} satisfies PersonAttr;

console.log(seyi.age)


const myFunc = (constraint: PersonAttr) => {
  //const { height } = constraint;
  if(constraint.height) {
      console.log(constraint.height.toUpperCase())
  }
}

myFunc(seyi)

import { StrictMode } from "react";

function App() {
  return (
    <div>
      <Header />
      <StrictMode>
        <div>
          <ComponentOne />
          <ComponentTwo />
        </div>
      </StrictMode>
      <Header />
    </div>
  );
}

import * as schema from './schema';
import { drizzle } from "drizzle-orm/mysql2";
import mysql from "mysql2/promise";
const connection = await mysql.createConnection({
  uri: process.env.PLANETSCALE_DATABASE_URL,
});
const db = drizzle(connection, { schema, mode: 'planetscale' });

function createMarkup() {
  return {
      __html: 'First &middot; second'
  }
}

function MyComponent() {
  return (
      <div dangeriouslySetInnerHTML={createMarkup()} />
  )
}

@setTitle('Profile')
export class MyComponent extends React.FC {
  constructor(props) {
      super(props)
  }
  render() {
      
  }
}

export const setTitle = (title) => (WrappedComponent) => {
  return class extends React.FC (
      componentDidMount() {
          document.title = title;
      }
      render() { return (<WrappedComponent {...this.props} />) }
  )
}

import React, { useState, useEffect } from 'react';
export default function WindowDimension() {
  const [{height, width}, setDimension] = useState({
      height: window.innerHeight,
      width: window.innerWidth
  })

  useEffect(() => {
      function resizeWindow() {
          setDimension({
              height: window.innerHeight,
              width: window.innerWidth
          })
      }
      window.addEventListener('resize', resizeWindow)
      return () => window.removeEventListener('resize', resizeWindow)
  }, [])

  return (
      <span>height: {height} width: {width}</span>
  )
}

async function foo() {
  await 1;
}
It is also equivalent to:

JS
Copy to Clipboard
function foo() {
  return Promise.resolve(1).then(() => undefined);
}

const btConnection = await navigator.permissions.query({ name: "bluetooth" });
if(btConnection !=- "denied"){
    //do something
}

import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '../server/routers/_app';
function getBaseUrl() {
  if (typeof window !== 'undefined')
    // browser should use relative path
    return '';
  if (process.env.VERCEL_URL)
    // reference for vercel.com
    return `https://${process.env.VERCEL_URL}`;
  if (process.env.RENDER_INTERNAL_HOSTNAME)
    // reference for render.com
    return `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}`;
  // assume localhost
  return `http://localhost:${process.env.PORT ?? 3000}`;
}
export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    return {
      links: [
        httpBatchLink({
          /**
           * If you want to use SSR, you need to use the server's full URL
           * @link https://trpc.io/docs/v11/ssr
           **/
          url: `${getBaseUrl()}/api/trpc`,
          // You can pass any HTTP headers you wish here
          async headers() {
            return {
              // authorization: getAuthCookie(),
            };
          },
        }),
      ],
    };
  },
  /**
   * @link https://trpc.io/docs/v11/ssr
   **/
  ssr: false,
});

MyElement.prototype.loadData = function (url) {
  if (this._cache[url]) {
    queueMicrotask(() => {
      this._setData(this._cache[url]);
      this.dispatchEvent(new Event("load"));
    });
  } else {
    fetch(url)
      .then((res) => res.arrayBuffer())
      .then((data) => {
        this._cache[url] = data;
        this._setData(data);
        this.dispatchEvent(new Event("load"));
      });
  }
};

name: Playwright Tests
on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
jobs:
  test:
    timeout-minutes: 60
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: actions/setup-node@v4
      with:
        node-version: 18
    - name: Install dependencies
      run: npm ci
    - name: Install Playwright Browsers
      run: npx playwright install --with-deps
    - name: Run Playwright tests
      run: npx playwright test
    - uses: actions/upload-artifact@v4
      if: ${{ !cancelled() }}
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 30


        {
          "root": "apps/cart",
          "sourceRoot": "apps/cart/src",
          "projectType": "application",
          "generators": {},
          "targets": {
            "build": {
              "executor": "@nx/webpack:webpack",
              "options": {
                "outputPath": "dist/apps/cart",
                ...
              }
            },
            "test": {
              "executor": "@nx/jest:jest",
              "options": {
                ...
              }
            }
          }
        }

  interface Shape {
      getArea(): number;
  }
  
  class Rectangle implements Shape {
      constructor(private width: number, private height: number) {}
  
      private static hello: string;
  
      getArea(): number {
          return this.width * this.height;
      }
  }
  
  class Circle implements Shape {
      constructor(private radius: number) {}
  
      getArea(): number {
      return Math.PI * this.radius * this.radius;
      }
  }
  
  function calculateTotalArea(shapes: T[]): number {
      let totalArea = 0;
      for (let shape of shapes) {
      totalArea += shape.getArea();
      }
      return totalArea;
  }
  
  let rectangle = new Rectangle(5, 10);
  let circle = new Circle(3);
  
  let totalArea = calculateTotalArea([rectangle, circle]);
  console.log(totalArea); // Output: 104.71238898038469



Old Transform:

import React from "react";

function App() {
  return <h1>Good morning!!</h1>;
}
Now JSX transform convert the above code into regular JavaScript as below,

import React from "react";

function App() {
  return React.createElement("h1", null, "Good morning!!");
}
New Transform:

The new JSX transform doesn't require any React imports

function App() {
  return <h1>Good morning!!</h1>;
}
Under the hood JSX transform compiles to below code

import { jsx as _jsx } from "react/jsx-runtime";

function App() {
  return _jsx("h1", { children: "Good morning!!" });
}

import React, { useState, useEffect } from 'react';

function MyComponent() {
  const [data, setData] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch('https://api.example.com/data');
        const jsonData = await response.json();
        setData(jsonData);
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    };

    fetchData();
  }, []); // Empty dependency array ensures this effect runs only once

  return (
    <div>
      {data ? (
        <div>
          {/* Render data */}
        </div>
      ) : (
        <div>Loading...</div>
      )}
    </div>
  );
}

export default MyComponent;


import { Console, Effect } from 'effect'

class CustomError {
  readonly _tag = 'CustomError'
  constructor(readonly value: number) {}
}

const maybeFail: Effect.Effect<
  number,
  CustomError // type safety
> = Effect.sync(() => Math.random()).pipe(
  Effect.andThen((value) =>
    value > 0.5
      ? Effect.fail(new CustomError(value))
      : Effect.succeed(value),
  ),
)


const main = maybeFail.pipe(
  Effect.andThen((value) =>
    Console.log(`Got value ${value}`),
  ),
  Effect.catchTag("CustomError", (error) =>
    Console.error(`Oops! Got value ${error.value}`),
  ),
)


Effect.runPromise(main) 



import { Effect, pipe } from 'effect';

function getData(): Effect.Effect<never, FetchError| JSONError| ParseError, Data> {
    return pipe(
        Effect.tryPromise({
            try: () => fetch(url),
            catch: () => new FetchError()
        }),
        Effect.flatMap(res => Effect.tryPromise({
            try: () => res.json(),
            catch: () => new JSONError()
        })),
        Effect.flatMap(json => Effect.try({
            try: () => dataSchema.parse(json),
            catch: () => new ParseError()
        }))
    )
}

import { useNavigate } from "react-router-dom";

function useLogoutTimer() {
  const userIsInactive = useFakeInactiveUser();
  const navigate = useNavigate();

  useEffect(() => {
    if (userIsInactive) {
      fake.logout();
      navigate("/session-timed-out");
    }
  }, [userIsInactive]);
}

type Effect<Success, Error, Requirement> = (content: Context<Requirement>) => Success | Error

function SubmitButton() {
  const navigation = useNavigation();
  if (navigation.formMethod) {
    console.log(navigation.formMethod); // post
  }

  return (
    <Form method="POST">
      <button>Submit</button>
    </Form>
  );
}

class BarError {
  readonly _tag = "BarError"
}
class FooError {
  readonly _tag = "FooError"
}

const conditions [true, true, true] as [boolean, boolean, boolean];

const Errors = Effect.gen(function* (_) {
  if(conditions[0]) {
      yield* _(Effect.fail(new BarError()))
  } else if (conditions[1]) {
      yield* _(Effect.fail(new FooError()))
  } else if(conditions[2){
      yield* _(Effect.die(Boom))
  }
  return "Success"
})

class SimpleClass {
  #data;
    index;

  constructor(data) {
    this.#data = data;
      this.index = 0
  }

next() {
    
    if (this.index < this.#data.length) {
      return { value: this.#data[this.index++], done: false };
    } else {
      return { done: true };
    }
  }

  [Symbol.iterator]() {
    // Use a new index for each iterator. This makes multiple
    // iterations over the iterable safe for non-trivial cases,
    // such as use of break or nested looping over the same iterable.
    
    return this;
  }
}

const simple = new SimpleClass([1, 2, 3, 4, 5]);

for (const val of simple) {
  console.log(val); // 1 2 3 4 5
}

// vitest.config.ts
import { defineConfig } from 'vitest/config'

export default defineConfig({
  test: {
    globals: true,
  },
})

const inventory = [
  { name: "asparagus", type: "vegetables", quantity: 5 },
  { name: "bananas", type: "fruit", quantity: 0 },
  { name: "goat", type: "meat", quantity: 23 },
  { name: "cherries", type: "fruit", quantity: 5 },
  { name: "fish", type: "meat", quantity: 22 },
];
const result = Object.groupBy(inventory, ({ type }) => type);
console.log(result)