brew install minikube // Kubernetes installation

this installation comes with docker and kubectl installed.
minikube start -vm hyperkite // start the orchestration with the hypervisor
kubectl create deployment nginx-depl --image=nginx // create the deployment(container) from nginx image.
kubectl exec -it nginx-depl bin/bash 
kubectl get  service // shows all the service available
Amazon EKS control tool - Amazon Elastic Kubernetes Service. 

docker build -t my-app:1.0 

//queryOptions
function groupOptions() {
    return defineOption({
        queryKey: ["group"],
        queryFn: async() => await fetch(url),
        staleTime: 6 * 60 * 1000,
        select: (data) => data.length,
    })
}

//useInfiniteQuery
useInfiniteQuery({
    queryKey: ["projects"],
    queryFn: async({queryKey, pageParam}) => await fetch(`/api/projects/?cursor=${pageParam}`).then(response => response.json()),
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor
})

//SSR using react query 

//setup _app.js 
import { QueryClientProvider, QueryClient, HydrationBoundary } from "@tanstack/react-query";

export default function MyApp({Component, pageProps}) {
    const [qc] = React.useState(() => new QueryClient({
        defaultOptions: {
            queries: {
                staleTime: 5 * 1000
            }
        },
        queryOptions: {},
        mutationOptions: {}
    }))
    return (
        <QueryClientProvider client={qc}>
            <HydrationBoundary client={dehydrate(qc)}>
                <Component {...pageProps} />
            </HydrationBoundary>
        </QueryClientProvider>
    )
}

//project/tasks.page
const getProjectTasksPage = async ({ queryKey, signal }) => {
    const response = await fetch(url + queryKey, { signal })
    if(!response.ok) throw new Error(response.statusText)
    return response.json()
}
const qc = new QueryClient();
export async function getServerSideProps(context) {
    await qc.prefetchQuery({
        queryKey: ["project", "tasks"],
        queryFn: getProjectTasks
    })
    return {
        props: {
            dehydratedState: dehydrate(qc)
        }
    }
}

function Tasks() {
    const { data } = useQuery({ queryKey: ["project", "tasks"], queryFn: getProjectTasks})
    const { data: comments } = useQuery({ queryKey: ["project", "comments"], queryFn: getProjectTaskCommnet})

    return (
        <>
            {data.project.tasks.map((task) => (<>{task.title}</>))}
            {comments}
        </>
    )
}

export default function TaskRoute({ dehydratedState }) {

    return (
        <HydrationBoundary client={dehydratedState}>
            <Tasks />
        </HydrationBoundary>
    )
}

//customHook testing 
import { waitFor, renderHook } from '@testing-library/react'

const wrapper = ({ Component, pageProps, children }) => {
    <QueryClientProvider client={qc}>
        <Component {...pageProps} /> {children} <Outlet />
    </QueryClientProvider>
}
const { result } = renderHook(() => customHook(), { wrapper })
await waitFor(() => expect(result.current.isSuccess).tobe(true))
expect(result.current.data).toEqual('Hello')


//Route handlers
export async function GET(request: Request) {
    const data = await fetch('/api/settings', {
        signal: signal,
        headers: { 'Content-Type': 'application/json', 'Accept': 'application/json', 'API-KEY': 'hello' },
        next: {
            revalidate: 60,
            tags: ['settings']
        }
    }).then(response => response.json())
    return Response.json({ data })
}
